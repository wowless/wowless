local data = require('wowapi.data')
local yamlnull = require('lyaml').null

local function loadApis(version)
  local apis = {}
  for fn, yaml in pairs(data.apis) do
    local match = not yaml.versions
    if yaml.versions then
      for _, v in ipairs(yaml.versions) do
        if version == v then
          match = true
        end
      end
    end
    if match then
      apis[fn] = yaml
    end
  end
  return apis
end

local getStub = (function()
  local defaultOutputs = {
    bool = 'false',
    ['nil'] = 'nil',
    number = '1',
    oneornil = 'nil',
    string = '\'\'',
    table = '{}',
    unknown = 'nil',
  }
  local structureDefaults = {}
  for name, st in pairs(data.structures) do
    structureDefaults[name] = (function()
      local t = {}
      for _, field in ipairs(st.fields) do
        local v = tostring(defaultOutputs[field.nilable and 'nil' or field.type])
        table.insert(t, ('[%q]=%s'):format(field.name, v))
      end
      return '{' .. table.concat(t, ',') .. '}'
    end)()
  end
  return function(sig)
    local rets = {}
    for _, out in ipairs(sig) do
      local v = defaultOutputs[out.nilable and 'nil' or out.type] or structureDefaults[out.type]
      assert(v, ('invalid output type %q'):format(out.type))
      table.insert(rets, v)
    end
    return loadstring('return ' .. table.concat(rets, ', '))
  end
end)()

local argSig = (function()
  local typeSigs = {
    boolean = 'b',
    ['function'] = 'f',
    ['nil'] = 'x',
    number = 'n',
    string = 's',
    table = 't',
    userdata = 'u',
  }
  return function(fn, ...)
    -- Ignore trailing nils for our purposes.
    local last = select('#', ...)
    while last > 0 and (select(last, ...)) == nil do
      last = last - 1
    end
    local sig = ''
    for i = 1, last do
      local ty = type((select(i, ...)))
      local c = typeSigs[ty]
      if not c then
        error(('invalid argument %d of type %q to %q'):format(i, ty, fn))
      end
      sig = sig .. c
    end
    return sig
  end
end)()

local function unpackReturns(r)
  local ret = {}
  for i, v in ipairs(r) do
    ret[i] = v ~= yamlnull and v or nil
  end
  return unpack(ret, 1, #r)
end

local function doGetFn(api, env)
  if api.status == 'autogenerated' or api.status == 'unimplemented' then
    return getStub(api.outputs or {})
  elseif api.status == 'stub' then
    return function() return unpackReturns(api.returns) end
  elseif api.status == 'implemented' then
    local args = {}
    for _, st in ipairs(api.states or {}) do
      table.insert(args, st == 'env' and env or data.state[st].value)
    end
    local impl = data.impl[api.name]
    return function(...)
      local t = {}
      for _, v in ipairs(args) do
        table.insert(t, v)
      end
      local n = select('#', ...)
      for i = 1, n do
        local v = select(i, ...)
        if i then
          t[#args + i] = v
        end
      end
      return impl(unpack(t, 1, #args + n))
    end
  else
    error(('invalid status %q on %q'):format(api.status, api.name))
  end
end

local function getFn(api, env)
  local stub = doGetFn(api, env)
  return api.outputs == nil and stub or function(...)
    return (function(...)
      for idx, out in ipairs(api.outputs) do
        if out.mixin then
          local t = select(idx, ...)
          if t then
            env.Mixin(t, env[out.mixin])
          end
        end
      end
      return ...
    end)(stub(...))
  end
end

local function loadFunctions(version, env, log)
  local fns = {}
  for fn, api in pairs(loadApis(version)) do
    local bfn = getFn(api, env)
    local impl = (function()
      if api.inputs then
        assert(#api.inputs == 1, api.name)
        local sig = api.inputs[1]
        return function(...)
          for i, param in ipairs(sig) do
            local arg = select(i, ...)
            if arg == nil then
              assert(
                param.nilable or param.default ~= nil,
                ('arg %d (%q) of %q is not nilable, but nil was passed'):format(
                  i, tostring(param.name), fn))
            else
              local ty = type(arg)
              local nty = ty == 'boolean' and 'bool' or ty
              assert(
                nty == param.type,
                ('arg %d (%q) of %q is of type %q, but %q was passed'):format(
                  i, tostring(param.name), fn, param.type, nty))
            end
          end
          return bfn(...)
        end
      end
      if api.oldinputs == nil then
        return bfn
      end
      local apisigs = api.oldinputs
      if type(apisigs) == 'string' then
        apisigs = {apisigs}
      end
      if type(apisigs) ~= 'table' then
        error(('invalid inputs type on %q'):format(fn))
      end
      return function(...)
        local fsig = argSig(fn, ...)
        for _, x in ipairs(apisigs) do
          if fsig == x then
            return bfn(...)
          end
        end
        error(('invalid arguments to %q, expected one of {%s}, got %q'):format(fn, table.concat(apisigs, ', '), fsig))
      end
    end)()
    local function wrapimpl(...)
      log(4, 'entering %s', api.name)
      local t = {...}
      local n = select('#', ...)
      return (function(success, ...)
        log(4, 'leaving %s (%s)', api.name, success and 'success' or 'failure')
        assert(success, ...)
        return ...
      end)(pcall(function() return impl(unpack(t, 1, n)) end))
    end
    local dot = fn:find('%.')
    if dot then
      local p = fn:sub(1, dot-1)
      fns[p] = fns[p] or {}
      fns[p][fn:sub(dot+1)] = wrapimpl
    else
      fns[fn] = wrapimpl
    end
  end
  return fns
end

return {
  argSig = argSig,
  getFn = getFn,
  loadApis = loadApis,
  loadFunctions = loadFunctions,
}
