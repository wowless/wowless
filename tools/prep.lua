local args = (function()
  local parser = require('argparse')()
  parser:argument('product', 'product to fetch')
  return parser:parse()
end)()

local product = args.product
local function parseYaml(...)
  return (assert(require('wowapi.yaml').parseFile(...)))
end
local function readFile(...)
  return (assert(require('pl.file').read(...)))
end
local plprettywrite = require('pl.pretty').write

local getStub = (function()
  local structures = require('wowapi.data').structures[product]
  local defaultOutputs = {
    boolean = 'false',
    ['function'] = 'function() end',
    ['nil'] = 'nil',
    number = '1',
    oneornil = 'nil',
    string = '\'\'',
    table = '{}',
    unknown = 'nil',
  }
  local structureDefaults = {}
  local function ensureStructureDefault(name)
    if structureDefaults[name] == nil then
      structureDefaults[name] = true
      local st = structures[name]
      local t = {}
      for _, field in ipairs(st.fields) do
        local v
        if structures[field.type] then
          ensureStructureDefault(field.type)
          v = structureDefaults[field.type]
        elseif field.type == 'table' and structures[field.innerType] then
          ensureStructureDefault(field.innerType)
          v = '{' .. structureDefaults[field.innerType] .. '}'
        elseif field.stub then
          assert(type(field.stub) == 'string', 'only string stubs supported in structures')
          v = string.format('%q', field.stub)
        else
          v = tostring(defaultOutputs[field.nilable and 'nil' or field.type])
        end
        if field.mixin then
          v = ('Mixin(%s,%s)'):format(v, field.mixin)
        end
        if v ~= 'nil' then
          table.insert(t, ('[%q]=%s'):format(field.name, v))
        end
      end
      structureDefaults[name] = '{' .. table.concat(t, ',') .. '}'
    else
      assert(structureDefaults[name] ~= true, 'loop in structure definitions')
    end
  end
  for name in pairs(structures) do
    ensureStructureDefault(name)
  end
  return function(sig)
    local rets = {}
    for _, out in ipairs(sig) do
      local v
      if out.stub or out.default then
        local value = out.stub or out.default
        local ty = type(value)
        if ty == 'number' or ty == 'boolean' then
          v = tostring(value)
        elseif ty == 'string' then
          v = string.format('%q', value)
        elseif ty == 'table' then
          v = plprettywrite(value)
        else
          error('unsupported stub value type ' .. ty)
        end
      elseif out.nilable then
        v = 'nil'
      else
        v = defaultOutputs[out.type] or structureDefaults[out.type]
      end
      assert(v, ('invalid output type %q'):format(out.type))
      table.insert(rets, v)
    end
    return 'return ' .. table.concat(rets, ', ')
  end
end)()

local apis = {}
local impls = {}
local sqlcursors = {}
local sqllookups = {}
do
  local cfg = parseYaml('data/products/' .. product .. '/apis.yaml')
  for name, apiname in pairs(cfg) do
    local apicfg = parseYaml('data/api/' .. apiname .. '.yaml')
    if not apicfg.debug then
      if apicfg.status == 'implemented' and not impls[apiname] then
        impls[apiname] = readFile('data/impl/' .. apiname .. '.lua')
      elseif apicfg.status == 'autogenerated' or apicfg.status == 'unimplemented' then
        apicfg.stub = getStub(apicfg.outputs or {})
      end
      for _, sql in ipairs(apicfg.sqls or {}) do
        if sql.cursor then
          sqlcursors[sql.cursor] = {
            sql = readFile('data/sql/cursor/' .. sql.cursor .. '.sql'),
            table = sql.table,
          }
        elseif sql.lookup then
          sqllookups[sql.lookup] = {
            sql = readFile('data/sql/lookup/' .. sql.lookup .. '.sql'),
            table = sql.table,
          }
        end
      end
      apis[name] = apicfg
    end
  end
end

local function supported(obj)
  if not obj.products then
    return true
  end
  for _, p in ipairs(obj.products) do
    if p == args.product then
      return true
    end
  end
  return false
end

local cvars = {}
for k, v in pairs(parseYaml('data/products/' .. product .. '/cvars.yaml')) do
  cvars[k:lower()] = {
    name = k,
    value = v,
  }
end

local events = {}
for k, v in pairs(parseYaml('data/products/' .. product .. '/events.yaml')) do
  events[k] = {
    neverSent = v.payload == nil or nil,
    payload = v.payload or {},
  }
end

local state = {}
for _, f in ipairs(require('pl.dir').getfiles('data/state')) do
  local cfg = parseYaml(f)
  state[cfg.name] = cfg.value
end

local uiobjects = {}
for _, d in ipairs(require('pl.dir').getdirectories('data/uiobjects')) do
  local name = d:match('/(%a+)$')
  local cfg = parseYaml(d .. '/' .. name .. '.yaml')
  if supported(cfg) then
    local methods = {}
    for k, v in pairs(cfg.methods or {}) do
      if supported(v) then
        if v.status == 'implemented' then
          v.impl = readFile('data/uiobjects/' .. name .. '/' .. k .. '.lua')
        end
        methods[k] = v
      end
    end
    cfg.methods = methods
    uiobjects[cfg.name] = cfg
  end
end

local data = {
  apis = apis,
  build = parseYaml('data/products/' .. product .. '/build.yaml'),
  cvars = cvars,
  events = events,
  globals = parseYaml('data/products/' .. product .. '/globals.yaml'),
  impls = impls,
  sqlcursors = sqlcursors,
  sqllookups = sqllookups,
  state = state,
  structures = parseYaml('data/products/' .. product .. '/structures.yaml'),
  uiobjects = uiobjects,
  xml = parseYaml('data/products/' .. product .. '/xml.yaml'),
}
local txt = 'return ' .. plprettywrite(data)
assert(require('pl.file').write('build/products/' .. args.product .. '/data.lua', txt))
